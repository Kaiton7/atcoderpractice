
絶対値の合計の最小化
個の数 𝑎1, 𝑎2, 𝑎3, … , 𝑎𝑁 があります。|𝑥 − 𝑎1| +| 𝑥 − 𝑎2|+ ⋯ + |𝑥 − 𝑎𝑁|
 の最小値を求めなさい。
実は、最小値となる 𝑥 は「𝑎1, 𝑎2, 𝑎3, … , 𝑎𝑁 の中央値」

リストをセットにすることでfindが早くなるメリットが在る
高さを考慮する問題は、注目しているモノ以外でも間に在るものの高さに注意する
再起の限界数は気をつける

セグメントツリーはモノイドにのみ利用できる。
1inexedに注意

bit木はiまでの総和、iの更新が可能
LSBと木の深さが合致する

二分法？端からやるとN^3だが、真ん中を決めてからやると少なくなるかもしれない

最適化をするのではなく、しきい値を決めてあげる。そうすると各風船に猶予が何秒在るか分かる
その猶予内に割れるかどうか高い順に割っていく


投げなくても良いという選択肢を0点にする。４回あるなら、２回ずつに分ける
２階分は全探索しておいて、残り最適なものを二分探索する

薄氷割のように、何回も繰り返すものはループ抜けた後にフィールドを戻す

タプルやリストのインデックスに列、値に行を指定することができる

BFSは最短距離のリストをもっておいて、頂点訪問時に、その前の頂点の最短距離に+1する

代入と比較演算子気をつける

#zombi
ダイクストラで行ってはいけない街を管理する時は
setを使うと簡単に管理できるし、無駄な探索を減らせる




#atcoder207
DPを使ってメモ再起
kに関してDPを更新してから、メモを更新する。
メモにはiに関する情報を持たせなくても、i毎にDPとmemoを更新するから問題ない
memo[k][mo]:i番目まで見たときにk分割して、i番目までの総和をk+1で割ったときの余りをmoとしてその場合の数
DP[i][k]:i番目まで見てk分割したときの場合の数。答えはsum_{k_iを1からNまで}DP[N][k_i]

平行移動は重心の移動と一致するので、両方の重心を移動させて原点に合わせれば良い。
ちなみに全体をN倍しておくと、小数にならずにすむ
回転は複素数で表す。ベクトルaをベクトルbに合わせる回転はb/aで表せるから簡単
誤差を考慮して判定する


G revenge of TSP
メモ化するときは、メモを利用できる条件に注意する
最初INFで初期化して、メモをするときに、最小化などをするときの初期値をINFする
そして、判定を!=INFで行うと、既に訪問して、INFとしてメモしているのに
同じパスを探索することとなる。








todo
bittree
segment tree
tree dp
max flow















